\documentclass{article}

\title{The Irmo Multiplayer Game Library}

\author{sdh300@zepler.net}
\date{November 2003}

\begin{document}

\maketitle
\tableofcontents
\pagebreak

\section{Overview}

\subsection{The Peer-to-Peer model}

Traditional multiplayer games have been based on a peer-to-peer model.
In this, each player in the game acts as a ``peer''. This 
relies on modelling the game world as a deterministic system. The
only unpredictable input, therefore, is the input of the players into
the game. Each peer transmits the player's input to the other peers.

This has the advantage of being a very simple system to implement. However,
it has a number of disadvantages:

\begin{itemize}

\item
 
Random input into the game is difficult to model. Typically this
involves using a pseudo random number generator where each node starts
from a common random seed. This is particularly important as game AI
typically makes heavy use of random numbers.

\item

Fluctuations in the network traffic can have large effects on the 
playability of the game. Any interruption in traffic from one peer
in the game will cause the game to freeze until the connection is
resumed. As the probability of an interruption increases with the
number of peers, this model does not scale well to large numbers
of players.

\item

Allowing players to join a game while in progress is difficult.
It is difficult to transmit the complete game state to a joining
peer. This is troublesome for the players as they must prearrange
games rather than simply joining one in progress.

\end{itemize}

\subsection{Client-Server Architecture}

The Client-Server architecture is a model which solves many of the 
problems inherent in the Peer-to-Peer architecture. In the 
Client-Server architecture, the game world exists in a server 
process, and the players send their input into this world from 
client processes. The server sends updates about the state of
the game world to the client processes.

Implementing an efficient client-server multiplayer engine is 
a difficult task. Most games implement a complete engine 
from scratch. The Irmo library aims to be a generic multiplayer
engine which can be used as a base for many different types of
multiplayer games and easily extended.

\subsection{Extension Languages}

Another common theme in many modern games is that of extension
languages. Many games use a high level extension language to describe
the game logic while using a lower level language such as C
to perform operations such as graphical rendering. Examples of
this are Quake's ``QuakeC'' language and the AisleRiot solitaire
game's use of the Guile extension language.

While providing client-server functionality, Irmo also aims to
provide cross-language abstraction such that the server can
be written in a high level language with the client written
in a lower level language. For this reason, a language binding
already exists for the Ruby scripting language. Bindings are
planned for other high-level languages.

\section{API Notes}

\subsection{Compiling}

Irmo uses the \texttt{pkg-config} system to store information about
the library and allow programs which use it to be built more 
easily. To find out more about \texttt{pkg-config}. Typically 
all that needs to be done is to add to the \texttt{CFLAGS}
and \texttt{LDFLAGS} variables of the \texttt{Makefile}:

\begin{quote}\begin{verbatim}
	CFLAGS += `pkg-config --cflags irmo`
	LDFLAGS += `pkg-config --libs irmo`
\end{verbatim}\end{quote}

\subsection{GLib}

Irmo makes use of the GLib library. GLib provides implementations of
a number of common and useful data structures and algorithms, as well
as standardised type definitions for portability. It is not 
neccessary to have in depth knowledge of GLib to use the Irmo library, 
but the programmer may find it useful to understand the basic
types defined by the GLib library. More information can be found 
in the GLib manual:

\begin{quote}http://developer.gnome.org/doc/API/2.0/glib/\end{quote}

\section{Interface Specification}

Irmo allows the programmer to describe the game world.  It is 
assumed that the world consists of a number of objects.  An
interface must first be defined describing these types of objects.
This is done by writing an Interface Specification File.

\subsection{Interface Specification File}

The following is an example of an Interface Specification file:

\begin{quote}\begin{verbatim}
// Irmo interface specification file for astro

class Object {
        int16 x;
        int16 y;
        int16 angle;
        int16 scale;
}

class PlayerObject : Object {
        irmo_objid_t player;
}

class Explosion : Object {
        int8 time;
}

class Missile : Object {}
class Asteroid : Object {}

class Player {
        string name;
        int16 score;
        irmo_objid_t avatar;
}

method fire(irmo_objid_t player);
\end{verbatim}\end{quote}

Here a number of classes are defined. These define the types of object
which can exist within the game world. A base class is defined named
``Object'' for all objects within the game world which the player sees.
These objects all have a number of common properties: in this case,
a pair of x,y coordinates, an angle and a scale (size). 

A number of subclasses are made of this class using the `:' operator
for the particular different types of object.  Some of these subclasses
contain additional data in addition to the data inherited from the
parent class.  For example, the ``Explosion'' class contains a ``time''
variable; explosions in the game expand and this is used to indicate 
the current size of the explosion.

As well as game objects, objects are also created to represent each
player within the game. These contain information such as the player's 
name and current score.

Finally, the specification file allows methods to be declared. These
are methods which can be invoked by the clients on the world.

\subsection{Base Types}

There are several base types used for object variables and method 
arguments. These are:

\begin{itemize}
\item \begin{verbatim}int8\end{verbatim}

	- 8 bit unsigned integer

\item \begin{verbatim}int16\end{verbatim}

	- 16 bit unsigned integer

\item \begin{verbatim}int32\end{verbatim}

	- 32 bit unsigned integer

\item \begin{verbatim}irmo_objid_t\end{verbatim}

	- A reference to an Irmo Object. All objects within a world have
	  a number by which they can be referenced. This is a variable
	  containing such an identifier.

\item \begin{verbatim}string\end{verbatim}

	- A text string.

\end{itemize}

\subsection{Loading the Interface Specification}

The Interface Specification is loaded using the 
\texttt{irmo\_interface\_spec\_new} function call. The library
includes a parser which parses the file given and returns a
\texttt{IrmoInterfaceSpec} object representing the interface.

\begin{quote}\begin{verbatim}
	IrmoInterfaceSpec *spec;

	spec = irmo_interface_spec_new("asteroids.if");
\end{verbatim}\end{quote}

If an error occurs during parsing an error message is printed
to \texttt{STDERR} and the function returns \texttt{NULL}.

\section{World Representation}

\subsection{IrmoWorld}

Having defined the interface and types of object which can be 
created in the game world, Irmo then allows the programmer
to create these objects.

All objects are created belonging to a ``container'' object, of
type \texttt{IrmoWorld}. A new \texttt{IrmoWorld} object is 
created using the
\texttt{irmo\_world\_new} function call. For example:

\begin{quote}\begin{verbatim}
	IrmoWorld *world;

	world = irmo_world_new(spec);
\end{verbatim}\end{quote}

Creating a world object requires giving an interface specification,
as described in the previous section. \texttt{irmo\_world\_new} 
returns a pointer to the new world object.

Having created a world object, objects can be created belonging to the
world with the types defined in the Interface Specification. Each object
in the world has a unique numeric identifier. A reference to the object
can be found from its ID using the \texttt{irmo\_world\_get\_object\_for\_id}
function call. For example:

\begin{quote}\begin{verbatim}
	IrmoObject *object;

	// search for object 55

	object = irmo_world_get_object_for_id(world, 55);
\end{verbatim}\end{quote}

If there is no object in the world with the identifier given, the function
returns NULL.

Similarly, it is possible to iterate over objects in an 
\texttt{IrmoWorld} using the \texttt{irmo\_world\_foreach\_object}
function. This is performed by passing a pointer to a function to 
call for each object. For example:

\begin{quote}\begin{verbatim}
	void my_object_callback(IrmoObject *object, gpointer user_data)
	{
		// ... perform operation for each object ...
	}

	...

	irmo_world_foreach_object(world, NULL, my_object_callback, NULL);
\end{verbatim}\end{quote}

The function allows the programmer to specify the name of a class: this
allows the iterator to iterate over only objects of a particular class.
If the class has subclasses, these are included as well.
In the above example, NULL is passed to specify all objects of any class.

\end{document}

